<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Lamprey Labs</title>
        <link>https://lampreylabs.com/posts/</link>
        <description>Recent content in Posts on Lamprey Labs</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>This work is licensed under the GNU General Public License v3.0</copyright>
        <lastBuildDate>Wed, 13 Jul 2022 00:00:00 +0000</lastBuildDate>
        <atom:link href="https://lampreylabs.com/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Practical Reverse Engineering - Exercise 1, Page 11</title>
            <link>https://lampreylabs.com/posts/2022/07/practical-reverse-engineering-exercise-1-page-11/</link>
            <pubDate>Wed, 13 Jul 2022 00:00:00 +0000</pubDate>
            
            <guid>https://lampreylabs.com/posts/2022/07/practical-reverse-engineering-exercise-1-page-11/</guid>
            <description>Table of Contents  Question Answer  Question This function uses a combination SCAS and STOS to do its work. First, explain what is the type of the [EBP+8] and [EBP+C] in line 1 and 8, respectively. Next, explain what this snippet does.
01: mov edi, [ebp + 8] 02: mov edx, edi 03: xor eax, eax 04: or ecx, 0FFFFFFFFh 05: repne scasb 06: add ecx, 2 07: neg ecx 08: mov al, [ebp + 0Ch] 09: mov edi, edx 10: rep stosb 11: mov eax, edx Answer [EBP + 8h] appears to be a char buffer pointer/PCHAR(size = 4 bytes) since it is loaded into EDI register which is then implicitly used by scasb instruction with repne prefix as the memory operand address to compare for a particular byte value specified by AL register.</description>
            <content type="html"><![CDATA[<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#answer">Answer</a></li>
</ul>
<h2 id="question">Question</h2>
<p>This function uses a combination <code>SCAS</code> and <code>STOS</code> to do its work. First, explain what is the type of the <code>[EBP+8]</code> and <code>[EBP+C]</code> in line 1 and 8, respectively. Next, explain what this snippet does.</p>
<pre><code class="language-x86asm" data-lang="x86asm">01: mov edi, [ebp + 8]
02: mov edx, edi
03: xor eax, eax
04: or ecx, 0FFFFFFFFh
05: repne scasb
06: add ecx, 2
07: neg ecx
08: mov al, [ebp + 0Ch]
09: mov edi, edx
10: rep stosb
11: mov eax, edx
</code></pre><h2 id="answer">Answer</h2>
<p><code>[EBP + 8h]</code> appears to be a char buffer pointer/<code>PCHAR</code>(size = 4 bytes) since it is loaded into <code>EDI</code> register which is then implicitly used by <code>scasb</code> instruction with <code>repne</code> prefix as the memory operand address to compare for a particular byte value specified by <code>AL</code> register.</p>
<p><code>[EBP + 0Ch]</code> appears to be a <code>CHAR</code>(size = 1 byte) since it is loaded into <code>AL</code> register which is then implicitly used by <code>stosb</code> instruction with <code>rep</code> prefix as the byte value to store into the destination operand given by <code>EDI</code> register.</p>
<p>Line 1 sets <code>EDI</code> to the value at address <code>(EBP+8h)</code> which is probably the first argument(<code>PCHAR</code>) passed to this function following the <code>__cdecl/__stdcall</code> calling convention.</p>
<p>Line 2 sets <code>EDX</code> with <code>EDI</code>, essentially saving a copy of the first parameter in <code>EDX</code> register. This is necessary because in Line 5 when <code>scasb</code> is used, it automatically increments/decrements <code>EDI</code> based on <code>EFLAGS.DF</code>, therefore, trashing the original value.</p>
<p>Line 3 performs <code>Bitwise Exclusive OR</code> operation on <code>EAX</code> with itself, thereby clearing it to 0.</p>
<p>Line 4 performs <code>Bitwise Inclusive OR</code> operation on <code>ECX</code> with <code>0xFFFFFFFF</code>, thereby setting it to <code>0xFFFFFFFF</code>.</p>
<p>Line 5 uses the <code>scasb</code> instruction to scan the string(pointed to by <code>EDI</code>) for the <code>NULL</code> byte terminator(given by <code>AL</code>) one byte at a time. <code>repne</code> prefix(which uses <code>ECX</code> as an unsigned counter) is used to indicate to keep scanning until it finds the <code>NULL</code> byte. This will also decrement <code>ECX</code> for each byte scanned until the <code>NULL</code> byte is encountered.</p>
<p>Line 6 adds 2 to <code>ECX</code> to compensate for counting from -1 instead of 0 and including the <code>NULL</code> byte.</p>
<p>Line 7 replaces <code>ECX</code> with its 2&rsquo;s complement, thereby turning it into a positive value. Now, <code>ECX</code> contains the length of the string excluding the <code>NULL</code> byte.</p>
<p>Line 8 sets <code>AL</code> to the value at address <code>(EBP+0xC)</code> which is probably the second argument(<code>CHAR</code>) passed to this function following the <code>__cdecl/__stdcall</code> calling convention.</p>
<p>Line 9 sets <code>EDI</code> with <code>EDX</code> to prime it with the destination operand address for the next instruction.</p>
<p>Line 10 uses the <code>stosb</code> instruction to store the byte(given by <code>AL</code>) into the string(pointed to by <code>EDI</code>) one byte at a time. <code>rep</code> prefix is used to indicate to keep setting until <code>ECX</code> decrements to 0(i.e. the entire length of the string).</p>
<p>Line 11 sets <code>EAX</code> with <code>EDX</code> now pointing to the overwritten string. <code>EAX</code> register holds the return value when returning from a procedure.</p>
<p>Based on all of the above, we can construct a decompilation of the assembly snippet as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#f00">extern</span> <span style="color:#87ceeb">&#34;C&#34;</span> <span style="color:#f00">__declspec</span>(noinline) PCHAR <span style="color:#f00">__cdecl</span> asm_func(
  _In_ PCHAR pchBuffer,
  _In_ CHAR  chValue
) {
  memset(pchBuffer, chValue, strlen(pchBuffer));
  <span style="color:#f00">return</span> pchBuffer;
}
</code></pre></div>]]></content>
        </item>
        
    </channel>
</rss>
