<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Lamprey Labs</title>
        <link>https://lampreylabs.com/posts/</link>
        <description>Recent content in Posts on Lamprey Labs</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>This work is licensed under the GNU General Public License v3.0</copyright>
        <lastBuildDate>Wed, 11 Jan 2023 00:00:00 +0000</lastBuildDate>
        <atom:link href="https://lampreylabs.com/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Hacksys Extreme Vulnerable Driver(HEVD) Windows Driver Exploitation - Stack Buffer Overflow</title>
            <link>https://lampreylabs.com/posts/2023/01/hacksys-extreme-vulnerable-driverhevd-windows-driver-exploitation-stack-buffer-overflow/</link>
            <pubDate>Wed, 11 Jan 2023 00:00:00 +0000</pubDate>
            
            <guid>https://lampreylabs.com/posts/2023/01/hacksys-extreme-vulnerable-driverhevd-windows-driver-exploitation-stack-buffer-overflow/</guid>
            <description>Table of Contents  Brief Vulnerability Exploitation and Stabilization  Case I: Intel OS Guard/SMEP not present, KVA Shadow/KPTI disabled   Patch Analysis Honourable Mention  Brief The vulnerability class in question that we are going to hunt for and exploit is a Stack Buffer Overflow in HEVD.sys Windows driver compiled without stack cookie/canary(/GS Buffer Security Check) or StackGuard mitigation. We are also going to look at productization and stabilization of the exploit later on.</description>
            <content type="html"><![CDATA[<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#brief">Brief</a></li>
<li><a href="#vulnerability">Vulnerability</a></li>
<li><a href="#exploitation-and-stabilization">Exploitation and Stabilization</a>
<ul>
<li><a href="#case-i">Case I: <code>Intel OS Guard</code>/<code>SMEP</code> not present, <code>KVA Shadow</code>/<code>KPTI</code> disabled</a></li>
</ul>
</li>
<li><a href="#patch-analysis">Patch Analysis</a></li>
<li><a href="#honourable-mention">Honourable Mention</a></li>
</ul>
<h2 id="brief">Brief</h2>
<p>The vulnerability class in question that we are going to hunt for and exploit is a <code>Stack Buffer Overflow</code> in <code>HEVD.sys</code> <code>Windows</code> driver compiled without stack cookie/canary(<code>/GS</code> Buffer Security Check) or <code>StackGuard</code> mitigation. We are also going to look at productization and stabilization of the exploit later on.</p>
<blockquote>
<p>We are only going to consider <code>Intel 64</code>(64-bit version of the <code>x86</code> <code>ISA</code>) targets in this blog post unless explicitly stated otherwise.</p>
</blockquote>
<h2 id="vulnerability">Vulnerability</h2>
<p>First off, we should grab the latest version of the <a href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver">HEVD</a> binary that we are going to exploit. I am going to use <code>HEVD v3.00</code>.</p>
<p>Our next step would be to of course load the vulnerable version of the binary in <code>IDA Pro</code> for static analysis. You could also use <code>IDA Free/Demo/Home</code> or any other disassembler of your choice. <code>Hex-Rays</code> decompiler is not strictly necessary although it would certainly be helpful.</p>
<p>We will be utilizing the provided <code>PDB</code> symbol file which will greatly aid us in <code>RE</code> and later on we will also take a look at the patch to discuss how the vulnerability was fixed.</p>
<blockquote>
<p>An useful <code>IDA Pro</code> plugin for initial automated analysis of <code>Windows</code> drivers is <a href="https://github.com/VoidSec/DriverBuddyReloaded">DriverBuddyReloaded</a> by <a href="https://twitter.com/Void_Sec">VoidSec</a>. It may provide us with a useful starting point and save some time in the process.</p>
</blockquote>
<p>After opening the binary, we land in <code>GsDriverEntry()</code> routine which doesn&rsquo;t look anything like the <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nc-wdm-driver_initialize">DriverEntry()</a> routine that we are familiar with. It is actually inserted by the compiler when the code is compiled with the <a href="https://learn.microsoft.com/en-us/cpp/build/reference/gs-buffer-security-check?view=msvc-170">/GS</a> compiler flag and performs some initialization to support the detection of buffer overruns.</p>
<p><img src="/img/hevd-gs-entry-point.PNG" alt="hevd-gs-entry-point" title="hevd-gs-entry-point"></p>
<p>We can simply follow the call to a function appropriately named here as <code>DriverEntry_0()</code>. Now, this looks more like it! We can already see the device name string and the <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/introduction-to-ms-dos-device-names">MS-DOS</a> device name string that are initialized to <a href="https://learn.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-_unicode_string">nt!_UNICODE_STRING</a> structures using <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-rtlinitunicodestring">nt!RtlInitUnicodeString()</a> routine.</p>
<p><img src="/img/hevd-real-entry-point.PNG" alt="hevd-real-entry-point" title="hevd-real-entry-point"></p>
<p>We can use <code>Hex-Rays</code> decompiler to decompile this function and note three things that are of concern to us:</p>
<ol>
<li>Creation of the named device object for the driver using <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-iocreatedevice">nt!IoCreateDevice()</a> routine. Notably, it doesn&rsquo;t use <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdmsec/nf-wdmsec-wdmlibiocreatedevicesecure">nt!IoCreateDeviceSecure()</a> routine that lets us implement access control. This potentially implies that any process running on the system even one with a <strong>Low Integrity Level</strong> token can open a handle to this device object.</li>
<li>Creation of the symbolic link object to the device by using <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-iocreatesymboliclink">nt!IoCreateSymbolicLink()</a> routine and supplying the <code>MS-DOS</code> device name for the device object. This is necessary to work with the driver from a user-mode application.</li>
<li>Setting the pointer to the <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/dispatchdevicecontrol-and-dispatchinternaldevicecontrol-routines">DispatchDeviceControl</a> dispatch routine in the <code>MajorFunction[]</code> array of the driver object to handle <code>IRP_MJ_DEVICE_CONTROL</code> requests. For more information, refer to the <code>MSDN</code> documentation on the <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_driver_object">nt!_DRIVER_OBJECT structure</a> and <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/irp-mj-device-control">IRP_MJ_DEVICE_CONTROL</a>.</li>
</ol>
<p><img src="/img/hevd-real-entry-point-decompiled.PNG" alt="hevd-real-entry-point-decompiled" title="hevd-real-entry-point-decompiled"></p>
<p>Now that we have found the driver dispatch routine to handle <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp">IRPs</a> with <code>I/O</code> function code of <code>IRP_MJ_DEVICE_CONTROL</code>, we can start looking for the various functionalities implemented by the driver that we can trigger from a user-mode client application by sending the appropriate <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/defining-i-o-control-codes">IOCTL</a> code and <code>I/O</code> parameters using <a href="https://learn.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol">kernel32!DeviceIoControl()</a> routine.</p>
<p>And scrolling down a bit we found a call to <code>IOCTL</code> handler of stack buffer overflow thanks to the helpful debug prints baked into the code(yes, this happens sometimes in production builds too!)</p>
<p><img src="/img/hevd-dispatch-device-control-stack-buffer-overflow.PNG" alt="hevd-dispatch-device-control-stack-buffer-overflow" title="hevd-dispatch-device-control-stack-buffer-overflow"></p>
<p>But what is the <code>IOCTL</code> code through which we can take this code path?</p>
<p>Well, we just scroll up a bit in the control flow graph and spot some code that checks if <code>ECX == 0x222003</code> and jumps to the location we highlighted above if the condition is true. Looks like we have found the <code>IOCTL</code> code to trigger a stack buffer overflow!</p>
<p><img src="/img/hevd-stack-buffer-overflow-ioctl.PNG" alt="hevd-stack-buffer-overflow-ioctl" title="hevd-stack-buffer-overflow-ioctl"></p>
<p>We can now decode the <code>IOCTL</code> code using <a href="https://www.osronline.com/article.cfm%5Earticle=229.htm">OSR Online IOCTL Decoder</a>.</p>
<p><img src="/img/hevd-stack-buffer-overflow-ioctl-decoded.PNG" alt="hevd-stack-buffer-overflow-ioctl-decoded" title="hevd-stack-buffer-overflow-ioctl-decoded"></p>
<p>The most notable fact about this is that it uses <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/buffer-descriptions-for-i-o-control-codes#method_neither">METHOD_NEITHER</a> transfer type which means the <code>I/O</code> manager does not validate the buffers which reside in <code>UVAS</code> and are not copied to <code>KVAS</code>. It is up to the driver to implement proper sanity checks to determine if the buffers are safe to access from the driver.</p>
<p>Let&rsquo;s take a gander at the disassembly and decompilation of the <code>IOCTL</code> handler of stack buffer overflow using <code>IDA Pro</code> and <code>Hex-Rays</code> decompiler:</p>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">PAGE:0000000140086594     ; =============== S U B R O U T I N E =======================================
PAGE:0000000140086594
PAGE:0000000140086594
PAGE:0000000140086594     ; int __fastcall BufferOverflowStackIoctlHandler(_IRP *Irp, _IO_STACK_LOCATION *IrpSp)
PAGE:0000000140086594     BufferOverflowStackIoctlHandler proc near
PAGE:0000000140086594                                             ; CODE XREF: IrpDeviceIoCtlHandler+1D6↑p
PAGE:0000000140086594                                             ; DATA XREF: .pdata:0000000140084144↑o
PAGE:0000000140086594     Irp = rcx
PAGE:0000000140086594     IrpSp = rdx
PAGE:0000000140086594 000                 sub     rsp, 28h
PAGE:0000000140086598 028                 mov     Irp, [IrpSp+20h] ; UserBuffer
PAGE:000000014008659C 028                 mov     eax, 0C0000001h
PAGE:00000001400865A1 028                 mov     edx, [IrpSp+10h] ; Size
PAGE:00000001400865A4 028                 test    Irp, Irp
PAGE:00000001400865A7 028                 jz      short loc_1400865AE
PAGE:00000001400865A9 028                 call    TriggerBufferOverflowStack
PAGE:00000001400865AE
PAGE:00000001400865AE     loc_1400865AE:                          ; CODE XREF: BufferOverflowStackIoctlHandler+13↑j
PAGE:00000001400865AE 028                 add     rsp, 28h
PAGE:00000001400865B2 000                 retn
PAGE:00000001400865B2     BufferOverflowStackIoctlHandler endp
PAGE:00000001400865B2
PAGE:00000001400865B2     ; ---------------------------------------------------------------------------
</code></pre><p><img src="/img/hevd-stack-buffer-overflow-ioctl-handler-decompiled.PNG" alt="hevd-stack-buffer-overflow-ioctl-handler-decompiled" title="hevd-stack-buffer-overflow-ioctl-handler-decompiled"></p>
<p>The only thing this function does is extract the pointer to user&rsquo;s input buffer and its length from the current <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/i-o-stack-locations">I/O stack location</a> which were copied as-is by the <code>I/O</code> manager from the user-mode client application to the <code>nt!_IRP</code> and its accompanying <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_io_stack_location">nt!_IO_STACK_LOCATION</a> structure(s) without any form of checking and call <code>HEVD!TriggerBufferOverflowStack()</code> routine with the extracted values as arguments.</p>
<p>It looks as though the hunt is finally over as we descend upon the function which is so helpfully named <code>TriggerBufferOverflowStack()</code>:</p>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">PAGE:00000001400865B4     ; =============== S U B R O U T I N E =======================================
PAGE:00000001400865B4
PAGE:00000001400865B4
PAGE:00000001400865B4     ; __int64 __fastcall TriggerBufferOverflowStack(void *UserBuffer, size_t Size)
PAGE:00000001400865B4     TriggerBufferOverflowStack proc near    ; CODE XREF: BufferOverflowStackIoctlHandler+15↑p
PAGE:00000001400865B4                                             ; DATA XREF: .pdata:0000000140084150↑o
PAGE:00000001400865B4
PAGE:00000001400865B4     KernelBuffer    = dword ptr -818h
PAGE:00000001400865B4     var_18          = byte ptr -18h
PAGE:00000001400865B4     arg_0           = qword ptr  8
PAGE:00000001400865B4     arg_8           = qword ptr  10h
PAGE:00000001400865B4     arg_10          = qword ptr  18h
PAGE:00000001400865B4
PAGE:00000001400865B4     UserBuffer = rcx
PAGE:00000001400865B4     Size = rdx
PAGE:00000001400865B4     ; __unwind { // __C_specific_handler
PAGE:00000001400865B4 000                 mov     [rsp+arg_0], rbx
PAGE:00000001400865B9 000                 mov     [rsp+arg_8], rsi
PAGE:00000001400865BE 000                 mov     [rsp+arg_10], rdi
PAGE:00000001400865C3 000                 push    r12
PAGE:00000001400865C5 008                 push    r14
PAGE:00000001400865C7 010                 push    r15
PAGE:00000001400865C9 018                 sub     rsp, 820h
PAGE:00000001400865D0 838                 mov     rsi, Size
PAGE:00000001400865D3 838                 mov     rdi, UserBuffer
PAGE:00000001400865D6 838                 xor     ebx, ebx
PAGE:00000001400865D8 838                 mov     r12d, 800h
PAGE:00000001400865DE 838                 mov     r8d, r12d       ; Size
PAGE:00000001400865E1 838                 xor     edx, edx        ; Val
PAGE:00000001400865E3 838                 lea     UserBuffer, [rsp+838h+KernelBuffer] ; Dst
PAGE:00000001400865E8 838                 call    memset
PAGE:00000001400865ED 838                 nop
PAGE:00000001400865EE
PAGE:00000001400865EE     loc_1400865EE:                          ; DATA XREF: .rdata:00000001400025B0↑o
PAGE:00000001400865EE     ;   __try { // __except at $LN6_0       ; Alignment
PAGE:00000001400865EE 838                 lea     r8d, [rbx+1]
PAGE:00000001400865F2 838                 mov     edx, r12d       ; Length
PAGE:00000001400865F5 838                 mov     UserBuffer, rdi ; Address
PAGE:00000001400865F8 838                 call    cs:__imp_ProbeForRead
PAGE:00000001400865FE 838                 mov     r9, rdi
PAGE:0000000140086601 838                 lea     r8, aUserbuffer0xP ; &#34;[+] UserBuffer: 0x%p\n&#34;
PAGE:0000000140086608 838                 lea     r15d, [rbx+3]
PAGE:000000014008660C 838                 mov     edx, r15d       ; Level
PAGE:000000014008660F 838                 lea     r14d, [rbx+4Dh]
PAGE:0000000140086613 838                 mov     ecx, r14d       ; ComponentId
PAGE:0000000140086616 838                 call    cs:__imp_DbgPrintEx
PAGE:000000014008661C 838                 mov     r9, rsi
PAGE:000000014008661F 838                 lea     r8, aUserbufferSize ; &#34;[+] UserBuffer Size: 0x%X\n&#34;
PAGE:0000000140086626 838                 mov     edx, r15d       ; Level
PAGE:0000000140086629 838                 mov     ecx, r14d       ; ComponentId
PAGE:000000014008662C 838                 call    cs:__imp_DbgPrintEx
PAGE:0000000140086632 838                 lea     r9, [rsp+838h+KernelBuffer]
PAGE:0000000140086637 838                 lea     r8, aKernelbuffer0x ; &#34;[+] KernelBuffer: 0x%p\n&#34;
PAGE:000000014008663E 838                 mov     edx, r15d       ; Level
PAGE:0000000140086641 838                 mov     ecx, r14d       ; ComponentId
PAGE:0000000140086644 838                 call    cs:__imp_DbgPrintEx
PAGE:000000014008664A 838                 mov     r9d, r12d
PAGE:000000014008664D 838                 lea     r8, aKernelbufferSi ; &#34;[+] KernelBuffer Size: 0x%X\n&#34;
PAGE:0000000140086654 838                 mov     edx, r15d       ; Level
PAGE:0000000140086657 838                 mov     ecx, r14d       ; ComponentId
PAGE:000000014008665A 838                 call    cs:__imp_DbgPrintEx
PAGE:0000000140086660 838                 lea     r8, aTriggeringBuff_2 ; &#34;[+] Triggering Buffer Overflow in Stack&#34;...
PAGE:0000000140086667 838                 mov     edx, r15d       ; Level
PAGE:000000014008666A 838                 mov     ecx, r14d       ; ComponentId
PAGE:000000014008666D 838                 call    cs:__imp_DbgPrintEx
PAGE:0000000140086673 838                 mov     r8, rsi         ; MaxCount
PAGE:0000000140086676 838                 mov     Size, rdi       ; Src
PAGE:0000000140086679 838                 lea     UserBuffer, [rsp+838h+KernelBuffer] ; Dst
PAGE:000000014008667E 838                 call    memmove
PAGE:0000000140086683 838                 jmp     short loc_1400866A0
PAGE:0000000140086683     ;   } // starts at 1400865EE
PAGE:0000000140086685     ; ---------------------------------------------------------------------------
PAGE:0000000140086685
PAGE:0000000140086685     $LN6_0:                                 ; DATA XREF: .rdata:00000001400025B0↑o
PAGE:0000000140086685     ;   __except(1) // owned by 1400865EE
PAGE:0000000140086685 838                 mov     ebx, eax
PAGE:0000000140086687 838                 mov     r9d, eax
PAGE:000000014008668A 838                 lea     r8, aExceptionCode0 ; &#34;[-] Exception Code: 0x%X\n&#34;
PAGE:0000000140086691 838                 mov     edx, 3          ; Level
PAGE:0000000140086696 838                 lea     ecx, [Size+4Ah] ; ComponentId
PAGE:0000000140086699 838                 call    cs:__imp_DbgPrintEx
PAGE:000000014008669F 838                 nop
PAGE:00000001400866A0
PAGE:00000001400866A0     loc_1400866A0:                          ; CODE XREF: TriggerBufferOverflowStack+CF↑j
PAGE:00000001400866A0 838                 mov     eax, ebx
PAGE:00000001400866A2 838                 lea     r11, [rsp+838h+var_18]
PAGE:00000001400866AA 838                 mov     rbx, [r11+20h]
PAGE:00000001400866AE 838                 mov     rsi, [r11+28h]
PAGE:00000001400866B2 838                 mov     rdi, [r11+30h]
PAGE:00000001400866B6 838                 mov     rsp, r11
PAGE:00000001400866B9 018                 pop     r15
PAGE:00000001400866BB 010                 pop     r14
PAGE:00000001400866BD 008                 pop     r12
PAGE:00000001400866BF 000                 retn
PAGE:00000001400866BF     ; } // starts at 1400865B4
PAGE:00000001400866BF     TriggerBufferOverflowStack endp
</code></pre><p><img src="/img/hevd-stack-buffer-overflow-decompiled.PNG" alt="hevd-stack-buffer-overflow-decompiled" title="hevd-stack-buffer-overflow-decompiled"></p>
<p>The issue here(highlighted in red for your reading pleasure) is apparent. On one hand, we have a local variable called <code>Dst</code> and it is an array of type <code>CHAR</code> consisting of <code>0n2048/0x800</code> elements occupying <code>0n2048 * sizeof(CHAR) = 0n2048/0x800</code> bytes on the stack and on the other hand, we have an unsafe routine such as <a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/memmove-wmemmove?view=msvc-170">memmove()</a> taking attacker-controlled input data and size as arguments and copying it to the buffer on the stack without any form of size validation thus making it possible to overflow its bounds and corrupt adjacent data on the stack.</p>
<p>This bug appears to be exploitable in practice too because the input data and the input size both appear to be completely attacker-controlled without any constraints.</p>
<h2 id="exploitation-and-stabilization">Exploitation and Stabilization</h2>
<p>Our objective is exploiting this vulnerability to achieve arbitrary code execution in kernel-mode and we previously said that we can corrupt data on the stack using the vulnerability but how does corrupting random stack data help us in any way except maybe causing a glorious bugcheck on the device?</p>
<p>Well, as you might know, the <a href="https://namazso.github.io/x86/html/CALL.html">call</a> instruction <em>pushes</em> the <em>return address</em>(address of the subsequent instruction following the <code>call</code>) on the <em>stack</em> before changing the <em>(really)extended instruction pointer</em>(<code>EIP</code>/<code>RIP</code>) value to the <code>call</code> target and the <a href="https://namazso.github.io/x86/html/RET.html">ret</a> instruction <em>pops</em> the value at the <em>top of the stack</em> into <code>EIP</code>/<code>RIP</code>. They are both control flow instructions as they can be used to <em>control</em> the instruction pointer(a pointer to the next instruction to execute).</p>
<p>So what if we could overwrite a <code>retaddr</code> on the stack with the address of our payload buffer that we control? And when the function returns we are going to have our payload executed instead!</p>
<p>Now that we have defined our exploitation strategy, let&rsquo;s discuss some potential problems and how we resolve them:</p>
<ol>
<li>Legacy and modern exploit mitigations such as <code>KASLR</code>, <code>DEP</code>, <code>GS Cookie</code>, <code>KPP/PatchGuard</code>, <code>SMEP</code>, <code>SMAP</code>, <code>KPTI</code>, <code>kCFG</code>, <code>HyperGuard</code>, <code>HVCI</code>, <code>KCET</code> etc.</li>
</ol>
<ul>
<li>Some of them are not applicable here, some can be entirely avoided or bypassed and others will completely thwart us. We will discuss them in detail on a case-by-case basis.</li>
</ul>
<ol start="2">
<li>Where do we put our payload?</li>
</ol>
<ul>
<li>User Virtual Address Space(<code>UVAS</code>).</li>
</ul>
<ol start="3">
<li>What happens if our payload <code>UVA</code> gets paged out before we are done?</li>
</ol>
<ul>
<li>Lock the payload pages into physical memory thus ensuring that they cannot be written to the pagefile.</li>
</ul>
<ol start="4">
<li>How do we know how much stack data to corrupt to cause a precise overwrite of the <code>retaddr</code> and not any other arbitrary data on the stack which may lead to system instability?</li>
</ol>
<ul>
<li>We must first draw the complete stack layout with the help of the disassembly shown above in order to understand this.
<img src="/img/hevd-stack-buffer-overflow-stack-layout.PNG" alt="hevd-stack-buffer-overflow-stack-layout" title="hevd-stack-buffer-overflow-stack-layout">
Note that the offsets here are relative to the stack base containing the <code>retaddr</code>. From this diagram, we can see that after we overflow the bounds of the buffer <code>Dst</code> stored on stack into three non-volatile register contents also saved on stack we can finally overwrite the <code>retaddr</code>(ergo, <code>retaddr</code> offset = <code>0x800 + 0x8 * 0n3</code> = <strong><code>0x818</code></strong>). I&rsquo;ve seen some writeups use cyclic pattern generators for this purpose so feel free to confirm the above using <a href="https://zerosum0x0.blogspot.com/2016/11/overflow-exploit-pattern-generator.html">Overflow Exploit Pattern Generator - Online Tool
</a> by <a href="">@zerosum0x0</a>.
One thing to mention here is that we irreparably trash three saved non-volatile register contents on the stack(<code>R12</code>, <code>R14</code>, and <code>R15</code>) to get to the <code>retaddr</code> which is not ideal for stability but also unavoidable in our case.</li>
</ul>
<ol start="5">
<li>How do we pick up the original control flow and return back to user-mode after our payload finishes executing now that we have utterly messed up the stack?</li>
</ol>
<ul>
<li>There are quite a few approaches to deal with kernel-mode payload recovery or transitioning from <code>ring 0</code> to <code>ring 3</code> after successful exploitation, however, it is hard to find a universal method that is equally reliable or is the most optimal for every scenario. Ergo, we will again discuss them in detail on a case-by-case basis.</li>
</ul>
<h3 id="case-i">Case I</h3>
<ul>
<li><code>Intel OS Guard</code>/<code>SMEP</code> not present, <code>KVA Shadow</code>/<code>KPTI</code> disabled</li>
<li>Target
<ul>
<li><code>Windows 7</code> <code>OS</code> or <code>OS</code> &gt; <code>Windows 7</code> but running on older <code>Intel</code> hardware(μarch &lt; <code>Ivy Bridge</code>)</li>
<li><code>Intel</code> processor that <strong><em>is not</em></strong> vulnerable to <code>Rogue Data Cache Load</code>/<code>Meltdown</code>/<code>Variant 3</code>/<code>CVE-2017-5754</code> or without the <code>Meltdown</code> patch(<code>KPTI</code> disabled)</li>
</ul>
</li>
<li>Proof of Concept
<ul>
<li><a href="https://github.com/winterknife/HEVDExploitation/blob/master/StackBufferOverflow/main.cpp">StackBufferOverflow</a></li>
</ul>
</li>
</ul>
<p>This is the easiest case to deal with as there are no kernel security mitigations to defeat, so we will start with this one(baby steps!)</p>
<h4 id="kernel-mode-payload-recovery">Kernel-mode Payload Recovery</h4>
<p>In order to understand the most optimal approach for our case(and also perhaps the easiest), we need to consult the disassembly of the caller of <code>HEVD!TriggerBufferOverflowStack()</code> and see the location where our callee would have normally returned had the control flow not been hijacked to execute our payload.</p>
<p><img src="/img/hevd-stack-buffer-overflow-recovery-stub.PNG" alt="hevd-stack-buffer-overflow-recovery-stub" title="hevd-stack-buffer-overflow-recovery-stub"></p>
<p>Once we identify that, we can append the code stub(highlighted in red) to our payload so that we can execute it ourselves and return to <code>IRP_MJ_DEVICE_CONTROL</code> <code>IRP</code> handler which is eventually going to return out of kernel-mode without crashing the system.</p>
<h4 id="demo">Demo</h4>
<p>Here is a screenshot demonstrating successful exploitation of this vulnerability on a fully updated <code>Windows 7</code> system with a modified <a href="https://github.com/winterknife/PINKPANTHER">PINKPANTHER</a> payload to achieve <code>Local Privilege Escalation(LPE)</code>:</p>
<p><img src="/img/hevd-stack-buffer-overflow-lpe-poc.PNG" alt="hevd-stack-buffer-overflow-lpe-poc" title="hevd-stack-buffer-overflow-lpe-poc"></p>
<h2 id="patch-analysis">Patch Analysis</h2>
<p>So what was the fix? We can load the &ldquo;secure&rdquo; version of the binary into <code>IDA Pro</code> to find out.</p>
<p><img src="/img/hevd-stack-buffer-overflow-patch-analysis.PNG" alt="hevd-stack-buffer-overflow-patch-analysis" title="hevd-stack-buffer-overflow-patch-analysis"></p>
<p>Quite simple really as it turns out, by enforcing stringent bounds. As you might notice, the size parameter to <code>memmove()</code> is no longer attacker-controlled and it&rsquo;s fixed to <code>sizeof(KernelBuffer)</code> bytes which means that we will no longer be able to overrun the contents of this buffer on the stack beyond its bounds.</p>
<h2 id="honourable-mention">Honourable Mention</h2>
<p>Throughout this blog post I have assumed that the readers are already familiar with setting up a <code>Windows</code> test <code>VM</code> with full kernel debugging support and have done so but if that&rsquo;s not the case, I&rsquo;d implore you to give this a read: <a href="https://www.codemachine.com/articles/system_setup_for_kernel_development.html">CodeMachine System setup for kernel development and debugging guide</a></p>
]]></content>
        </item>
        
        <item>
            <title>Practical Reverse Engineering - Exercise 2, Page 35</title>
            <link>https://lampreylabs.com/posts/2022/08/practical-reverse-engineering-exercise-2-page-35/</link>
            <pubDate>Sun, 28 Aug 2022 00:00:00 +0000</pubDate>
            
            <guid>https://lampreylabs.com/posts/2022/08/practical-reverse-engineering-exercise-2-page-35/</guid>
            <description>Table of Contents  Question Answer  Question In the example walk-through, we did a nearly one-to-one translation of the assembly code to C. As an exercise, re-decompile this whole function so that it looks more natural. What can you say about the developer’s skill level/experience? Explain your reasons. Can you do a better job?
Answer We already saw a raw decompilation of the sample&amp;rsquo;s DllMain routine in the last exercise using the Hex-Rays decompiler but let&amp;rsquo;s further clean it up and polish it.</description>
            <content type="html"><![CDATA[<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#answer">Answer</a></li>
</ul>
<h2 id="question">Question</h2>
<p>In the example walk-through, we did a nearly one-to-one translation of
the assembly code to C. As an exercise, re-decompile this whole function
so that it looks more natural. What can you say about the developer’s skill level/experience? Explain your reasons. Can you do a better job?</p>
<h2 id="answer">Answer</h2>
<p>We already saw a <em>raw</em> decompilation of the sample&rsquo;s <code>DllMain</code> routine in the last exercise using the <code>Hex-Rays decompiler</code> but let&rsquo;s further clean it up and polish it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f00">typedef</span> <span style="color:#ee82ee">unsigned</span> <span style="color:#f00">__int16</span> WORD;  <span style="color:#0f0">// 2 byte
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span><span style="color:#f00">typedef</span> <span style="color:#ee82ee">unsigned</span> <span style="color:#f00">__int32</span> DWORD; <span style="color:#0f0">// 4 byte
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>
</span></span><span style="display:flex;"><span><span style="color:#0f0">// 0x6 bytes(sizeof)
</span></span></span><span style="display:flex;"><span><span style="color:#0f0">// Seems original developer(s) was/were unaware of structure packing?
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span><span style="color:#e5e5e5">#pragma pack(push, 1)
</span></span></span><span style="display:flex;"><span><span style="color:#e5e5e5"></span><span style="color:#f00">typedef</span> <span style="color:#f00">struct</span> _IDTR {
</span></span><span style="display:flex;"><span>    WORD  Limit; <span style="color:#0f0">// 0x0
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>    <span style="color:#0f0">// WORD Pad; // 0x2, padding inserted by compiler for alignment in absence of byte packing
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>    DWORD Base;  <span style="color:#0f0">// 0x2
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>} IDTR, *PIDTR;
</span></span><span style="display:flex;"><span><span style="color:#e5e5e5">#pragma pack(pop)
</span></span></span><span style="display:flex;"><span><span style="color:#e5e5e5"></span>
</span></span><span style="display:flex;"><span>BOOL <span style="color:#f00">__stdcall</span> <span style="color:#ff0">DllMain</span>(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
</span></span><span style="display:flex;"><span>  <span style="color:#0f0">// Init local variables
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>  IDTR idtr = { <span style="color:#f60">0</span> };
</span></span><span style="display:flex;"><span>  PROCESSENTRY32 processentry32;
</span></span><span style="display:flex;"><span>  HANDLE hProcessSnapshot = NULL;
</span></span><span style="display:flex;"><span>  DWORD dwParentPid = <span style="color:#f60">0</span>;
</span></span><span style="display:flex;"><span>  DWORD dwPid = <span style="color:#f60">0</span>;
</span></span><span style="display:flex;"><span>  BOOL bRet = FALSE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#0f0">// Store the contents of the IDTR to memory
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>  __sidt(&amp;idtr);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#0f0">// Check if IDT base address falls within range = 0x8003F400 to 0x80047400, if TRUE then return FALSE to fail DLL load else proceed with execution
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>  <span style="color:#0f0">// On x86 Windows XP, IDT is located at KVA = 0x8003f400 for CPU 0
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>  <span style="color:#f00">if</span> ((idtr.Base &gt; <span style="color:#f60">0x8003F400</span>) &amp;&amp; (idtr.Base &lt; <span style="color:#f60">0x80047400</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#f00">return</span> FALSE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#0f0">// Zero initialize PROCESSENTRY32 structure(in a weird manner for some reason), also why?
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>  processentry32.dwSize = <span style="color:#f60">0</span>;
</span></span><span style="display:flex;"><span>  __stosd(&amp;processentry32.cntUsage, <span style="color:#f60">0</span>, (<span style="color:#f00">sizeof</span>(processentry32) - <span style="color:#f60">4</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#0f0">// Take a snapshot of all the processes in the system
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>  hProcessSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span style="color:#f60">0</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#f00">if</span> (hProcessSnapshot == INVALID_HANDLE_VALUE)
</span></span><span style="display:flex;"><span>    <span style="color:#f00">return</span> FALSE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#0f0">// Set the size of the structure before using it
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>  processentry32.dwSize = <span style="color:#f00">sizeof</span>(PROCESSENTRY32); <span style="color:#0f0">// 0x128
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#0f0">// Retrieve information about the first process and exit if unsuccessful
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>  <span style="color:#f00">if</span> (Process32First(hProcessSnapshot, &amp;processentry32) == <span style="color:#f60">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#f00">return</span> FALSE; <span style="color:#0f0">// memory leak here
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#0f0">// Now, walk the snapshot of processes and check if a process with image name = &#34;explorer.exe&#34; exists
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>  <span style="color:#f00">do</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#f00">if</span> (_stricmp(processentry32.szExeFile, <span style="color:#87ceeb">&#34;explorer.exe&#34;</span>) == <span style="color:#f60">0</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#f00">break</span>;
</span></span><span style="display:flex;"><span>  } <span style="color:#f00">while</span>(Process32Next(hProcessSnapshot, &amp;processentry32));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#0f0">// Get parent process ID and process ID
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>  dwParentPid = processentry32.th32ParentProcessID;
</span></span><span style="display:flex;"><span>  dwPid = processentry32.th32ProcessID;
</span></span><span style="display:flex;"><span>  <span style="color:#f00">if</span> (dwPid == dwParentPid) <span style="color:#0f0">// why?
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>    <span style="color:#f00">return</span> FALSE; <span style="color:#0f0">// memory leak here
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#0f0">// Perform actions based on the reason for calling
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>  <span style="color:#f00">switch</span>(fdwReason) {
</span></span><span style="display:flex;"><span>    <span style="color:#0f0">// The DLL is being loaded into the UVAS of the current process
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>    <span style="color:#f00">case</span> DLL_PROCESS_ATTACH:
</span></span><span style="display:flex;"><span>      <span style="color:#0f0">// Create a new thread in local process with start address = 0x100032D0
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>      CreateThread(NULL, <span style="color:#f60">0</span>, (LPTHREAD_START_ROUTINE)<span style="color:#f60">0x100032D0</span>, NULL, <span style="color:#f60">0</span>, NULL);
</span></span><span style="display:flex;"><span>      bRet = TRUE;
</span></span><span style="display:flex;"><span>      <span style="color:#f00">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#0f0">// The current process is creating a new thread
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>    <span style="color:#f00">case</span> DLL_THREAD_ATTACH:
</span></span><span style="display:flex;"><span>    <span style="color:#0f0">// A thread is exiting cleanly
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>    <span style="color:#f00">case</span> DLL_THREAD_DETACH:
</span></span><span style="display:flex;"><span>      bRet = TRUE;
</span></span><span style="display:flex;"><span>      <span style="color:#f00">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#0f0">// The DLL is being unloaded from the UVAS of the calling process
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>    <span style="color:#f00">case</span> DLL_PROCESS_DETACH:
</span></span><span style="display:flex;"><span>      bRet = FALSE;
</span></span><span style="display:flex;"><span>      <span style="color:#f00">break</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00">return</span> bRet; <span style="color:#0f0">// memory leak here
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>}
</span></span></code></pre></div><p>Regarding the developer&rsquo;s skill level/experience, we can infer that they were probably not very familiar with <code>Win32</code> <code>API</code> programming and didn&rsquo;t have a lot of experience in it(or writing software targeting multi-processor systems for that matter) based on the following points:</p>
<ol>
<li>Most modern <code>CPUs</code> are multi-core and each logical processor has its own <code>IDTR</code> but the code doesn&rsquo;t account for that. Instead, it just assumes that it will always run on <code>CPU 0</code> for what appears to be detection of <code>Windows XP</code>-based <code>VMs</code>. What happens if the thread runs the code on a different processor? Furthermore, it doesn&rsquo;t perform any <code>Windows</code> version checks for this purpose rendering it quite ineffective.</li>
<li>The <code>PROCESSENTRY32</code> structure is zero-initialized(in a weird manner nonetheless) when there&rsquo;s no requirement for that.</li>
<li>There exists some handle leaks due to the fact that the developer failed to close the handle to the process snapshot object as returned by <code>kernel32!CreateToolhelp32Snapshot()</code> as well as the handle to the thread object that is returned on a successful call to <code>kernel32!CreateThread()</code> while returning from the <code>DllMain</code> routine.</li>
<li>Finally, it is a bit unclear to us as to why the malware might be checking whether <code>explorer.exe</code> process exists yet not taking any definitive action based on the fact.</li>
</ol>
<p>It should be worth mentioning that is hard to deduce the developer&rsquo;s skill level based on the limited data that we have, however, it is no mystery that this malware sample is not particularly sophisticated. Au contraire, it&rsquo;s of the garden variety replete with programming and design mistakes.</p>
<p>Could we have done a better job than this?</p>
<p>Yes. ;)</p>
]]></content>
        </item>
        
        <item>
            <title>Practical Reverse Engineering - Exercise 1, Page 35</title>
            <link>https://lampreylabs.com/posts/2022/08/practical-reverse-engineering-exercise-1-page-35/</link>
            <pubDate>Wed, 24 Aug 2022 00:00:00 +0000</pubDate>
            
            <guid>https://lampreylabs.com/posts/2022/08/practical-reverse-engineering-exercise-1-page-35/</guid>
            <description>Table of Contents  Question Answer  Question Repeat the walk-through by yourself. Draw the stack layout, including parameters and local variables.
Answer Here is the VirusTotal link to the malware sample in question: wship4.dll
And here is the raw disassembly of the DllMain routine as generated by IDA Pro for reference:
.text:10001C60 ; =============== S U B R O U T I N E ======================================= .text:10001C60 .text:10001C60 ; Attributes: bp-based frame .</description>
            <content type="html"><![CDATA[<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#answer">Answer</a></li>
</ul>
<h2 id="question">Question</h2>
<p>Repeat the walk-through by yourself. Draw the stack layout, including
parameters and local variables.</p>
<h2 id="answer">Answer</h2>
<p>Here is the <code>VirusTotal</code> link to the malware sample in question:
<a href="https://www.virustotal.com/gui/file/2bef7e6b17643300cd8d98dd90a4c3cb0a051ee03272166c7d9589aa62652f6c/detection">wship4.dll</a></p>
<p>And here is the raw <em>disassembly</em> of the <code>DllMain</code> routine as generated by <code>IDA Pro</code> for reference:</p>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">.text:10001C60                                                  ; =============== S U B R O U T I N E =======================================
.text:10001C60
.text:10001C60                                                  ; Attributes: bp-based frame
.text:10001C60
.text:10001C60                                                  ; BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
.text:10001C60                                                  _DllMain@12     proc near               ; CODE XREF: DllEntryPoint+4B↓p
.text:10001C60
.text:10001C60                                                  pe              = PROCESSENTRY32 ptr -130h
.text:10001C60                                                  var_8           = byte ptr -8
.text:10001C60                                                  hinstDLL        = dword ptr  8
.text:10001C60                                                  fdwReason       = dword ptr  0Ch
.text:10001C60                                                  lpvReserved     = dword ptr  10h
.text:10001C60
.text:10001C60 000 55                                                           push    ebp
.text:10001C61 004 8B EC                                                        mov     ebp, esp
.text:10001C63 004 81 EC 30 01 00 00                                            sub     esp, 130h
.text:10001C69 134 57                                                           push    edi
.text:10001C6A 138 0F 01 4D F8                                                  sidt    fword ptr [ebp+var_8]
.text:10001C6E 138 8B 45 FA                                                     mov     eax, dword ptr [ebp+var_8+2]
.text:10001C71 138 3D 00 F4 03 80                                               cmp     eax, 8003F400h
.text:10001C76 138 76 10                                                        jbe     short loc_10001C88
.text:10001C78 138 3D 00 74 04 80                                               cmp     eax, 80047400h
.text:10001C7D 138 73 09                                                        jnb     short loc_10001C88
.text:10001C7F 138 33 C0                                                        xor     eax, eax
.text:10001C81 138 5F                                                           pop     edi
.text:10001C82 134 8B E5                                                        mov     esp, ebp
.text:10001C84 004 5D                                                           pop     ebp
.text:10001C85 000 C2 0C 00                                                     retn    0Ch
.text:10001C88                                                  ; ---------------------------------------------------------------------------
.text:10001C88
.text:10001C88                                                  loc_10001C88:                           ; CODE XREF: DllMain(x,x,x)+16↑j
.text:10001C88                                                                                          ; DllMain(x,x,x)+1D↑j
.text:10001C88 138 33 C0                                                        xor     eax, eax
.text:10001C8A 138 B9 49 00 00 00                                               mov     ecx, 49h ; &#39;I&#39;
.text:10001C8F 138 8D BD D4 FE FF FF                                            lea     edi, [ebp+pe.cntUsage]
.text:10001C95 138 C7 85 D0 FE FF FF 00 00 00 00                                mov     [ebp+pe.dwSize], 0
.text:10001C9F 138 50                                                           push    eax             ; th32ProcessID
.text:10001CA0 13C 6A 02                                                        push    2               ; dwFlags
.text:10001CA2 140 F3 AB                                                        rep stosd
.text:10001CA4 140 E8 2D 2F 00 00                                               call    CreateToolhelp32Snapshot
.text:10001CA9 138 8B F8                                                        mov     edi, eax
.text:10001CAB 138 83 FF FF                                                     cmp     edi, 0FFFFFFFFh
.text:10001CAE 138 75 09                                                        jnz     short loc_10001CB9
.text:10001CB0 138 33 C0                                                        xor     eax, eax
.text:10001CB2 138 5F                                                           pop     edi
.text:10001CB3 134 8B E5                                                        mov     esp, ebp
.text:10001CB5 004 5D                                                           pop     ebp
.text:10001CB6 000 C2 0C 00                                                     retn    0Ch
.text:10001CB9                                                  ; ---------------------------------------------------------------------------
.text:10001CB9
.text:10001CB9                                                  loc_10001CB9:                           ; CODE XREF: DllMain(x,x,x)+4E↑j
.text:10001CB9 138 8D 85 D0 FE FF FF                                            lea     eax, [ebp+pe]
.text:10001CBF 138 56                                                           push    esi
.text:10001CC0 13C 50                                                           push    eax             ; lppe
.text:10001CC1 140 57                                                           push    edi             ; hSnapshot
.text:10001CC2 144 C7 85 D0 FE FF FF 28 01 00 00                                mov     [ebp+pe.dwSize], 128h
.text:10001CCC 144 E8 FF 2E 00 00                                               call    Process32First
.text:10001CD1 13C 85 C0                                                        test    eax, eax
.text:10001CD3 13C 74 4F                                                        jz      short loc_10001D24
.text:10001CD5 13C 8B 35 C0 50 00 10                                            mov     esi, ds:_stricmp
.text:10001CDB 13C 8D 8D F4 FE FF FF                                            lea     ecx, [ebp+pe.szExeFile]
.text:10001CE1 13C 68 50 7C 00 10                                               push    offset String2  ; &#34;explorer.exe&#34;
.text:10001CE6 140 51                                                           push    ecx             ; String1
.text:10001CE7 144 FF D6                                                        call    esi ; _stricmp
.text:10001CE9 144 83 C4 08                                                     add     esp, 8
.text:10001CEC 13C 85 C0                                                        test    eax, eax
.text:10001CEE 13C 74 26                                                        jz      short loc_10001D16
.text:10001CF0
.text:10001CF0                                                  loc_10001CF0:                           ; CODE XREF: DllMain(x,x,x)+B4↓j
.text:10001CF0 13C 8D 95 D0 FE FF FF                                            lea     edx, [ebp+pe]
.text:10001CF6 13C 52                                                           push    edx             ; lppe
.text:10001CF7 140 57                                                           push    edi             ; hSnapshot
.text:10001CF8 144 E8 CD 2E 00 00                                               call    Process32Next
.text:10001CFD 13C 85 C0                                                        test    eax, eax
.text:10001CFF 13C 74 23                                                        jz      short loc_10001D24
.text:10001D01 13C 8D 85 F4 FE FF FF                                            lea     eax, [ebp+pe.szExeFile]
.text:10001D07 13C 68 50 7C 00 10                                               push    offset String2  ; &#34;explorer.exe&#34;
.text:10001D0C 140 50                                                           push    eax             ; String1
.text:10001D0D 144 FF D6                                                        call    esi ; _stricmp
.text:10001D0F 144 83 C4 08                                                     add     esp, 8
.text:10001D12 13C 85 C0                                                        test    eax, eax
.text:10001D14 13C 75 DA                                                        jnz     short loc_10001CF0
.text:10001D16
.text:10001D16                                                  loc_10001D16:                           ; CODE XREF: DllMain(x,x,x)+8E↑j
.text:10001D16 13C 8B 85 E8 FE FF FF                                            mov     eax, [ebp+pe.th32ParentProcessID]
.text:10001D1C 13C 8B 8D D8 FE FF FF                                            mov     ecx, [ebp+pe.th32ProcessID]
.text:10001D22 13C EB 06                                                        jmp     short loc_10001D2A
.text:10001D24                                                  ; ---------------------------------------------------------------------------
.text:10001D24
.text:10001D24                                                  loc_10001D24:                           ; CODE XREF: DllMain(x,x,x)+73↑j
.text:10001D24                                                                                          ; DllMain(x,x,x)+9F↑j
.text:10001D24 13C 8B 45 0C                                                     mov     eax, [ebp+fdwReason]
.text:10001D27 13C 8B 4D 0C                                                     mov     ecx, [ebp+fdwReason]
.text:10001D2A
.text:10001D2A                                                  loc_10001D2A:                           ; CODE XREF: DllMain(x,x,x)+C2↑j
.text:10001D2A 13C 3B C1                                                        cmp     eax, ecx
.text:10001D2C 13C 5E                                                           pop     esi
.text:10001D2D 138 75 09                                                        jnz     short loc_10001D38
.text:10001D2F 138 33 C0                                                        xor     eax, eax
.text:10001D31 138 5F                                                           pop     edi
.text:10001D32 134 8B E5                                                        mov     esp, ebp
.text:10001D34 004 5D                                                           pop     ebp
.text:10001D35 000 C2 0C 00                                                     retn    0Ch
.text:10001D38                                                  ; ---------------------------------------------------------------------------
.text:10001D38
.text:10001D38                                                  loc_10001D38:                           ; CODE XREF: DllMain(x,x,x)+CD↑j
.text:10001D38 138 8B 45 0C                                                     mov     eax, [ebp+fdwReason]
.text:10001D3B 138 48                                                           dec     eax
.text:10001D3C 138 75 15                                                        jnz     short loc_10001D53
.text:10001D3E 138 6A 00                                                        push    0               ; lpThreadId
.text:10001D40 13C 6A 00                                                        push    0               ; dwCreationFlags
.text:10001D42 140 6A 00                                                        push    0               ; lpParameter
.text:10001D44 144 68 D0 32 00 10                                               push    offset StartAddress ; lpStartAddress
.text:10001D49 148 6A 00                                                        push    0               ; dwStackSize
.text:10001D4B 14C 6A 00                                                        push    0               ; lpThreadAttributes
.text:10001D4D 150 FF 15 20 50 00 10                                            call    ds:CreateThread
.text:10001D53
.text:10001D53                                                  loc_10001D53:                           ; CODE XREF: DllMain(x,x,x)+DC↑j
.text:10001D53 138 B8 01 00 00 00                                               mov     eax, 1
.text:10001D58 138 5F                                                           pop     edi
.text:10001D59 134 8B E5                                                        mov     esp, ebp
.text:10001D5B 004 5D                                                           pop     ebp
.text:10001D5C 000 C2 0C 00                                                     retn    0Ch
.text:10001D5C                                                  _DllMain@12     endp
</code></pre><p>Here&rsquo;s how the stack diagram looks like at the start of the <code>DllMain</code> routine:</p>
<p><img src="/img/initial-stack-diagram-sample_J.PNG" alt="initial-stack-diagram-sample_J" title="initial-stack-diagram-sample_J"></p>
<p>And here&rsquo;s how the local stack frame looks like after the execution of the function prologue:</p>
<p><img src="/img/stack-diagram-after-function-prologue-sample_J.PNG" alt="stack-diagram-after-function-prologue-sample_J" title="stack-diagram-after-function-prologue-sample_J"></p>
<p>Note how <code>0x130</code> worth of space is allocated on the stack in what can only be presumed is for storing the local variables. Also, note that the offsets are now relative to the base frame pointer.</p>
<p>We can see from the above disassembly that one of the local variables is a structure of type <a href="https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/ns-tlhelp32-processentry32?redirectedfrom=MSDN">PROCESSENTRY32</a>(which <code>IDA</code> rather ambiguously has named <code>pe</code>). Now, we know that <code>sizeof(pe) == 0x128</code> bytes but the program allocated <code>0x130</code> bytes worth of space on the stack for local variables. That must mean that the second local variable(<code>var_8</code>) is of size <code>0x8</code> bytes.</p>
<p>A little later into the disassembly just after the function prologue, we can see that <code>var_8</code> is indeed used to store the contents of the <code>IDTR</code> using the <a href="https://namazso.github.io/x86/html/SIDT.html">sidt</a> instruction. In <code>x86</code> <code>nt</code>, the data structure used to represent the contents of the <code>GDT</code> and <code>IDT</code> registers is defined like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#0f0">// 0x8 bytes(sizeof)
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span><span style="color:#f00">typedef</span> <span style="color:#f00">struct</span> _DESCRIPTOR {
</span></span><span style="display:flex;"><span>    USHORT Pad;   <span style="color:#0f0">// 0x0
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>    USHORT Limit; <span style="color:#0f0">// 0x2
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>    ULONG  Base;  <span style="color:#0f0">// 0x4
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>} KDESCRIPTOR, *PKDESCRIPTOR;
</span></span></code></pre></div><p>Ergo, <code>var_8</code> can be inferred to be of type <a href="https://www.vergiliusproject.com/kernels/x86/Windows%207/SP1/_DESCRIPTOR">KDESCRIPTOR</a> which also corroborates our previous size calculation.</p>
<p>So the complete stack layout can be illustrated like so:</p>
<p><img src="/img/complete-stack-diagram-sample_J.PNG" alt="complete-stack-diagram-sample_J" title="complete-stack-diagram-sample_J"></p>
<p>Finally, we can see a raw <em>decompilation</em> of the above routine using <code>Hex-Rays decompiler</code> on <a href="https://dogbolt.org/">https://dogbolt.org/</a>:</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">15
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">16
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">17
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">18
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">19
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">20
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">21
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">22
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">23
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">24
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">25
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">26
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">27
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">28
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">29
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">30
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">31
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">32
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">33
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">34
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">35
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">36
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">37
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">38
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">39
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">40
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">41
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">42
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ee82ee">char</span> String2[] = <span style="color:#87ceeb">&#34;explorer.exe&#34;</span>; <span style="color:#0f0">// idb
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>
</span></span><span style="display:flex;"><span>BOOL <span style="color:#f00">__stdcall</span> <span style="color:#ff0">DllMain</span>(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  HANDLE Toolhelp32Snapshot; <span style="color:#0f0">// edi
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>  DWORD th32ParentProcessID; <span style="color:#0f0">// eax
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>  DWORD th32ProcessID; <span style="color:#0f0">// ecx
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>  PROCESSENTRY32 pe; <span style="color:#0f0">// [esp+4h] [ebp-130h] BYREF
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>  _WORD v8[<span style="color:#f60">4</span>]; <span style="color:#0f0">// [esp+12Ch] [ebp-8h] BYREF
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>
</span></span><span style="display:flex;"><span>  __sidt(v8);
</span></span><span style="display:flex;"><span>  <span style="color:#f00">if</span> ( *(_DWORD *)&amp;v8[<span style="color:#f60">1</span>] &gt; <span style="color:#f60">0x8003F400</span> &amp;&amp; *(_DWORD *)&amp;v8[<span style="color:#f60">1</span>] &lt; <span style="color:#f60">0x80047400</span> )
</span></span><span style="display:flex;"><span>    <span style="color:#f00">return</span> <span style="color:#f60">0</span>;
</span></span><span style="display:flex;"><span>  memset(&amp;pe, <span style="color:#f60">0</span>, <span style="color:#f00">sizeof</span>(pe));
</span></span><span style="display:flex;"><span>  Toolhelp32Snapshot = CreateToolhelp32Snapshot(<span style="color:#f60">2u</span>, <span style="color:#f60">0</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#f00">if</span> ( Toolhelp32Snapshot == (HANDLE)-<span style="color:#f60">1</span> )
</span></span><span style="display:flex;"><span>    <span style="color:#f00">return</span> <span style="color:#f60">0</span>;
</span></span><span style="display:flex;"><span>  pe.dwSize = <span style="color:#f60">296</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#f00">if</span> ( Process32First(Toolhelp32Snapshot, &amp;pe) )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#f00">if</span> ( !stricmp(pe.szExeFile, String2) )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>LABEL_10:
</span></span><span style="display:flex;"><span>      th32ParentProcessID = pe.th32ParentProcessID;
</span></span><span style="display:flex;"><span>      th32ProcessID = pe.th32ProcessID;
</span></span><span style="display:flex;"><span>      <span style="color:#f00">goto</span> LABEL_12;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#f00">while</span> ( Process32Next(Toolhelp32Snapshot, &amp;pe) )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#f00">if</span> ( !stricmp(pe.szExeFile, String2) )
</span></span><span style="display:flex;"><span>        <span style="color:#f00">goto</span> LABEL_10;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  th32ParentProcessID = fdwReason;
</span></span><span style="display:flex;"><span>  th32ProcessID = fdwReason;
</span></span><span style="display:flex;"><span>LABEL_12:
</span></span><span style="display:flex;"><span>  <span style="color:#f00">if</span> ( th32ParentProcessID == th32ProcessID )
</span></span><span style="display:flex;"><span>    <span style="color:#f00">return</span> <span style="color:#f60">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#f00">if</span> ( fdwReason == <span style="color:#f60">1</span> )
</span></span><span style="display:flex;"><span>    CreateThread(<span style="color:#f60">0</span>, <span style="color:#f60">0</span>, StartAddress, <span style="color:#f60">0</span>, <span style="color:#f60">0</span>, <span style="color:#f60">0</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#f00">return</span> <span style="color:#f60">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div>]]></content>
        </item>
        
        <item>
            <title>Practical Reverse Engineering - Exercise 4, Page 17</title>
            <link>https://lampreylabs.com/posts/2022/07/practical-reverse-engineering-exercise-4-page-17/</link>
            <pubDate>Thu, 21 Jul 2022 00:00:00 +0000</pubDate>
            
            <guid>https://lampreylabs.com/posts/2022/07/practical-reverse-engineering-exercise-4-page-17/</guid>
            <description>Table of Contents  Question Answer  Question In all of the calling conventions explained, the return value is stored in a 32-bit register(EAX). What happens when the return value does not fit in a 32-bit register? Write a program to experiment and evaluate your answer. Does the mechanism change from compiler to compiler?
Answer Let us consider the following C code:
extern &amp;#34;C&amp;#34; __declspec(noinline) unsigned __int64 __stdcall fun(  void ) {  return 0x4141414142424242; } Compiling it with x86 msvc v19.</description>
            <content type="html"><![CDATA[<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#answer">Answer</a></li>
</ul>
<h2 id="question">Question</h2>
<p>In all of the calling conventions explained, the return value is stored in a 32-bit register(<code>EAX</code>). What happens when the return value does not fit in a 32-bit register? Write a program to experiment and evaluate your answer. Does the mechanism change from compiler to compiler?</p>
<h2 id="answer">Answer</h2>
<p>Let us consider the following <code>C</code> code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f00">extern</span> <span style="color:#87ceeb">&#34;C&#34;</span> <span style="color:#f00">__declspec</span>(noinline) <span style="color:#ee82ee">unsigned</span> <span style="color:#f00">__int64</span> <span style="color:#f00">__stdcall</span> fun(
</span></span><span style="display:flex;"><span>  <span style="color:#ee82ee">void</span>
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00">return</span> <span style="color:#f60">0x4141414142424242</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Compiling it with <a href="https://godbolt.org/z/K4ab7soGP">x86 msvc v19.latest C/C++ compiler on godbolt.org</a> generates the following assembly code:</p>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">_fun@0  PROC
        push    ebp
        mov     ebp, esp
        mov     eax, 1111638594                     ; 42424242H
        mov     edx, 1094795585                     ; 41414141H
        pop     ebp
        ret     0
_fun@0  ENDP
</code></pre><p>And compiling it with <a href="https://godbolt.org/z/f968MKfG6">x86-64 icx 2022.0.0(Intel next-gen LLVM-based C/C++ compiler)</a> generates identical assembly code(minus creation of the base frame pointer controlled by compiler options):</p>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">fun:                                    # 
        mov     eax, 1111638594
        mov     edx, 1094795585
        ret
</code></pre><p>From the above, we can clearly see that the hard-coded 64-bit <em>integer value</em> is returned in <code>EDX:EAX</code>(the high-order <code>DWORD</code> is returned in <code>EDX</code> register and the low-order <code>DWORD</code> is returned in <code>EAX</code> register).</p>
<p>Although it certainly can change from compiler to compiler, this is all governed by a standardized <em>calling convention</em>(here seen using <code>Microsoft stdcall</code>). On the 32-bit <code>x86</code> architecture, all of the <code>C/C++</code> <em>calling conventions</em> adhere to the following rule(s) for returning <strong><em>integral types</em></strong>:</p>
<ol>
<li><strong>sizeof(return value) &lt;= 32 bits</strong>, return value is stored in <code>EAX</code></li>
<li><strong>32 bits &lt; sizeof(return value) &lt;= 64 bits</strong>, return value is stored in <code>EDX:EAX</code></li>
</ol>
<p>When <strong>sizeof(return value) &gt;= 64 bits</strong> or when returning large structures, the return value is stored in <code>EAX</code> register as a pointer to caller-allocated space on the stack that is passed to the callee as an implicit/hidden ﬁrst parameter on the stack.</p>
<p>For returning <strong><em>floating-point types</em></strong>, either the <code>SSE registers(XMM)</code> are used or are returned via the <code>x87 FPU</code> register stack.</p>
]]></content>
        </item>
        
        <item>
            <title>Practical Reverse Engineering - Exercise 3, Page 17</title>
            <link>https://lampreylabs.com/posts/2022/07/practical-reverse-engineering-exercise-3-page-17/</link>
            <pubDate>Wed, 20 Jul 2022 00:00:00 +0000</pubDate>
            
            <guid>https://lampreylabs.com/posts/2022/07/practical-reverse-engineering-exercise-3-page-17/</guid>
            <description>Table of Contents  Question Answer  Question In the example function, addme, what would happen if the stack pointer were not properly restored before executing RET?
Answer Here is the addme function for reference:
push ebp mov ebp, esp movsx eax, word ptr [ebp + 8h] movsx ecx, word ptr [ebp + 0Ch] add eax, ecx mov esp, ebp pop ebp ret In this particular case, ESP remains unmodified(equal to EBP) so mov esp, ebp can be safely omitted from the function epilogue.</description>
            <content type="html"><![CDATA[<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#answer">Answer</a></li>
</ul>
<h2 id="question">Question</h2>
<p>In the example function, <code>addme</code>, what would happen if the stack pointer
were not properly restored before executing <code>RET</code>?</p>
<h2 id="answer">Answer</h2>
<p>Here is the <code>addme</code> function for reference:</p>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">push ebp
mov ebp, esp
movsx eax, word ptr [ebp + 8h]
movsx ecx, word ptr [ebp + 0Ch]
add eax, ecx
mov esp, ebp
pop ebp
ret
</code></pre><p>In this particular case, <code>ESP</code> remains unmodified(equal to <code>EBP</code>) so <code>mov esp, ebp</code> can be safely omitted from the function epilogue.</p>
<p>However, we should remember that we pushed <code>EBP</code> onto the stack in the function prologue and now the top of the stack no longer contains the <code>retaddr</code> so if we removed the <code>pop ebp</code> instruction, the stack would become unbalanced and the subsequent <code>ret</code> instruction would transfer control back to saved <code>EBP</code> register value(which is probably not the valid <code>retaddr</code>) causing undefined behaviour or program crash.</p>
<p><img src="/img/balanced-stack-meme.jpg" alt="balanced-stack-meme" title="balanced-stack-meme"></p>
]]></content>
        </item>
        
        <item>
            <title>Practical Reverse Engineering - Exercise 2, Page 17</title>
            <link>https://lampreylabs.com/posts/2022/07/practical-reverse-engineering-exercise-2-page-17/</link>
            <pubDate>Tue, 19 Jul 2022 00:00:00 +0000</pubDate>
            
            <guid>https://lampreylabs.com/posts/2022/07/practical-reverse-engineering-exercise-2-page-17/</guid>
            <description>Table of Contents  Question Answer  Question Come up with at least two code sequences to set EIP to 0xAABBCCDD.
Answer There are several instructions in the x86 ISA to manipulate EIP register(control flow instructions) but in this exercise, we are going to see two of the most popular ones(and something which we&amp;rsquo;ve already encountered before in the previous exercise).
 CALL  call 0xAABBCCDD The call instruction is used to call a procedure; it pushes the retdaddr on the stack before changing EIP to the call target effectively transferring control to it.</description>
            <content type="html"><![CDATA[<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#answer">Answer</a></li>
</ul>
<h2 id="question">Question</h2>
<p>Come up with at least two code sequences to set <code>EIP</code> to <code>0xAABBCCDD</code>.</p>
<h2 id="answer">Answer</h2>
<p>There are several instructions in the <code>x86 ISA</code> to manipulate <code>EIP</code> register(control flow instructions) but in this exercise, we are going to see two of the most popular ones(and something which we&rsquo;ve already encountered before in the previous exercise).</p>
<ol>
<li><a href="https://namazso.github.io/x86/html/CALL.html">CALL</a></li>
</ol>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">call 0xAABBCCDD
</code></pre><p>The <code>call</code> instruction is used to call a procedure; it pushes the <code>retdaddr</code> on the stack before changing <code>EIP</code> to the call target effectively transferring control to it.</p>
<ol start="2">
<li><a href="https://namazso.github.io/x86/html/RET.html">RET</a></li>
</ol>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">push 0xAABBCCDD
ret
</code></pre><p>The <code>ret</code> instruction is used to return from a procedure; it pops whatever&rsquo;s at the top of the stack into <code>EIP</code> register and transfers control to it.</p>
<blockquote>
<p>Fun Fact: This method of changing the instruction pointer is often used in code-reuse attacks such as <code>Return Oriented Programming(ROP)</code>.</p>
</blockquote>
]]></content>
        </item>
        
        <item>
            <title>Practical Reverse Engineering - Exercise 1, Page 17</title>
            <link>https://lampreylabs.com/posts/2022/07/practical-reverse-engineering-exercise-1-page-17/</link>
            <pubDate>Sat, 16 Jul 2022 00:00:00 +0000</pubDate>
            
            <guid>https://lampreylabs.com/posts/2022/07/practical-reverse-engineering-exercise-1-page-17/</guid>
            <description>Table of Contents  Question Answer  Question Given what you learned about CALL and RET, explain how you would read the value of EIP? Why can’t you just do MOV EAX, EIP?
Answer mov eax, eip is seen as an invalid instruction(not encodable) by any assembler since EIP is not a General Purpose Register(GPR); it is a special purpose register that is used as a pointer to the next instruction to execute(hence known as, extended instruction pointer).</description>
            <content type="html"><![CDATA[<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#answer">Answer</a></li>
</ul>
<h2 id="question">Question</h2>
<p>Given what you learned about <code>CALL</code> and <code>RET</code>, explain how you would read
the value of <code>EIP</code>? Why can’t you just do <code>MOV EAX, EIP</code>?</p>
<h2 id="answer">Answer</h2>
<p><code>mov eax, eip</code> is seen as an invalid instruction(not encodable) by any assembler since <code>EIP</code> is not a <code>General Purpose Register(GPR)</code>; it is a special purpose register that is used as a pointer to the next instruction to execute(hence known as, <em>extended</em> instruction pointer).</p>
<p>However, there are a couple of tricks to get <code>EIP</code> register value by reading it from the stack following the execution of the <code>call</code> instruction.</p>
<p>Consider the following assembly subroutine(I&rsquo;m using <a href="https://docs.microsoft.com/en-us/cpp/assembler/masm/microsoft-macro-assembler-reference?view=msvc-170">MASM</a> as the assembler):</p>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">; Obtain instruction pointer(EIP) register value
OPTION LANGUAGE: SYSCALL
@get_eip@0 PROC PUBLIC
  ; Function prologue - save the non-volatile registers onto the stack and perform explicit stack frame linkage
  push ebp                      ; ESP = ESP - 0x4 and [ESP] = EBP, preserve the current base frame pointer on the stack
  mov ebp, esp                  ; EBP = ESP, create a new local stack frame within the callee by setting the base frame pointer to point to the current top of the stack

  ; Get the address of the instruction in the calling function immediately after the call instruction that will be executed after control returns to the caller
  mov eax, dword ptr [ebp + 4h] ; EAX = [EBP + 0x4], obtain the return address from the stack and store it into EAX

  ; Function epilogue - perform cleanup and return EAX register value to the calling procedure
  ;leave
  ;mov esp, ebp                 ; ESP = EBP, restore the stack by releasing the local stack frame
  pop ebp                       ; EBP = [ESP] and ESP = ESP + 0x4, restore the caller&#39;s base frame pointer
  ret                           ; EIP = [ESP] and ESP = ESP + 0x4, return from procedure
@get_eip@0 ENDP
OPTION LANGUAGE: C
</code></pre><p>And the corresponding function declaration in a header file to be able to call it from <code>C/C++</code> code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#f00">extern</span> <span style="color:#87ceeb">&#34;C&#34;</span> <span style="color:#f00">__declspec</span>(noinline) DWORD <span style="color:#f00">__fastcall</span> get_eip(
</span></span><span style="display:flex;"><span>  <span style="color:#ee82ee">void</span>
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>Note that the same function could also be written in <code>C</code> instead of assembly like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>DWORD <span style="color:#f00">__fastcall</span> <span style="color:#ff0">get_eip</span>(<span style="color:#ee82ee">void</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00">return</span> (DWORD)_ReturnAddress();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>To get <code>EIP</code> register value, we call the above subroutine:</p>
<p><img src="/img/before-call.PNG" alt="before-call" title="before-call"></p>
<p>After the <code>call</code> instruction is executed, <code>retaddr</code> is pushed onto the stack and <code>EIP</code> value is changed to the <code>call</code> target.</p>
<p><img src="/img/after-call.PNG" alt="after-call" title="after-call"></p>
<p>Note that the top of the stack now contains the return address. Also, note that <code>WinDbg</code> stack view displays lower memory addresses higher and higher memory addresses lower and that&rsquo;s why the stack appears to grow in the upward direction here.</p>
<p>We can read the <code>retaddr</code> from the stack by reading memory at address (<em>base frame pointer</em> + 0x4) and storing it into <code>EAX</code>.</p>
<p><img src="/img/get-retaddr.PNG" alt="get-retaddr" title="get-retaddr"></p>
<p>Finally, when the <code>ret</code> instruction is executed, the <code>retaddr</code> is popped from the stack into <code>EIP</code>.</p>
<p><img src="/img/eip.PNG" alt="eip" title="eip"></p>
<p>Note that after returning from the subroutine, <code>EAX</code> now contains the same value as <code>EIP</code>.</p>
<p>Another important thing to note is that using the <code>call $+5; pop eax</code> technique should be avoided altogether to prevent messing up the <code>Return Address Stack(RAS)</code> and causing branch mispredictions on older <code>Pentium Pro</code> processors.</p>
]]></content>
        </item>
        
        <item>
            <title>Practical Reverse Engineering - Exercise 1, Page 11</title>
            <link>https://lampreylabs.com/posts/2022/07/practical-reverse-engineering-exercise-1-page-11/</link>
            <pubDate>Wed, 13 Jul 2022 00:00:00 +0000</pubDate>
            
            <guid>https://lampreylabs.com/posts/2022/07/practical-reverse-engineering-exercise-1-page-11/</guid>
            <description>Table of Contents  Question Answer  Question This function uses a combination SCAS and STOS to do its work. First, explain what is the type of the [EBP+8] and [EBP+C] in line 1 and 8, respectively. Next, explain what this snippet does.
01: mov edi, [ebp + 8] 02: mov edx, edi 03: xor eax, eax 04: or ecx, 0FFFFFFFFh 05: repne scasb 06: add ecx, 2 07: neg ecx 08: mov al, [ebp + 0Ch] 09: mov edi, edx 10: rep stosb 11: mov eax, edx Answer [EBP + 8h] appears to be a char buffer pointer/PCHAR(size = 4 bytes) since it is loaded into EDI register which is then implicitly used by scasb instruction with repne prefix as the memory operand address to compare for a particular byte value specified by AL register.</description>
            <content type="html"><![CDATA[<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#answer">Answer</a></li>
</ul>
<h2 id="question">Question</h2>
<p>This function uses a combination <code>SCAS</code> and <code>STOS</code> to do its work. First, explain what is the type of the <code>[EBP+8]</code> and <code>[EBP+C]</code> in line 1 and 8, respectively. Next, explain what this snippet does.</p>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">01: mov edi, [ebp + 8]
02: mov edx, edi
03: xor eax, eax
04: or ecx, 0FFFFFFFFh
05: repne scasb
06: add ecx, 2
07: neg ecx
08: mov al, [ebp + 0Ch]
09: mov edi, edx
10: rep stosb
11: mov eax, edx
</code></pre><h2 id="answer">Answer</h2>
<p><code>[EBP + 8h]</code> appears to be a char buffer pointer/<code>PCHAR</code>(size = 4 bytes) since it is loaded into <code>EDI</code> register which is then implicitly used by <code>scasb</code> instruction with <code>repne</code> prefix as the memory operand address to compare for a particular byte value specified by <code>AL</code> register.</p>
<p><code>[EBP + 0Ch]</code> appears to be a <code>CHAR</code>(size = 1 byte) since it is loaded into <code>AL</code> register which is then implicitly used by <code>stosb</code> instruction with <code>rep</code> prefix as the byte value to store into the destination operand given by <code>EDI</code> register.</p>
<p>Line 1 sets <code>EDI</code> to the value at address <code>(EBP+8h)</code> which is probably the first argument(<code>PCHAR</code>) passed to this function following the <code>__cdecl/__stdcall</code> calling convention.</p>
<p>Line 2 sets <code>EDX</code> with <code>EDI</code>, essentially saving a copy of the first parameter in <code>EDX</code> register. This is necessary because in Line 5 when <code>scasb</code> is used, it automatically increments/decrements <code>EDI</code> based on <code>EFLAGS.DF</code>, therefore, trashing the original value.</p>
<p>Line 3 performs <code>Bitwise Exclusive OR</code> operation on <code>EAX</code> with itself, thereby clearing it to 0.</p>
<p>Line 4 performs <code>Bitwise Inclusive OR</code> operation on <code>ECX</code> with <code>0xFFFFFFFF</code>, thereby setting it to <code>0xFFFFFFFF</code>.</p>
<p>Line 5 uses the <code>scasb</code> instruction to scan the string(pointed to by <code>EDI</code>) for the <code>NULL</code> byte terminator(given by <code>AL</code>) one byte at a time. <code>repne</code> prefix(which uses <code>ECX</code> as an unsigned counter) is used to indicate to keep scanning until it finds the <code>NULL</code> byte. This will also decrement <code>ECX</code> for each byte scanned until the <code>NULL</code> byte is encountered.</p>
<p>Line 6 adds 2 to <code>ECX</code> to compensate for counting from -1 instead of 0 and including the <code>NULL</code> byte.</p>
<p>Line 7 replaces <code>ECX</code> with its 2&rsquo;s complement, thereby turning it into a positive value. Now, <code>ECX</code> contains the length of the string excluding the <code>NULL</code> byte.</p>
<p>Line 8 sets <code>AL</code> to the value at address <code>(EBP+0xC)</code> which is probably the second argument(<code>CHAR</code>) passed to this function following the <code>__cdecl/__stdcall</code> calling convention.</p>
<p>Line 9 sets <code>EDI</code> with <code>EDX</code> to prime it with the destination operand address for the next instruction.</p>
<p>Line 10 uses the <code>stosb</code> instruction to store the byte(given by <code>AL</code>) into the string(pointed to by <code>EDI</code>) one byte at a time. <code>rep</code> prefix is used to indicate to keep setting until <code>ECX</code> decrements to 0(i.e. the entire length of the string).</p>
<p>Line 11 sets <code>EAX</code> with <code>EDX</code> now pointing to the overwritten string. <code>EAX</code> register holds the return value when returning from a procedure.</p>
<p>Based on all of the above, we can construct a decompilation of the assembly snippet as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#f00">extern</span> <span style="color:#87ceeb">&#34;C&#34;</span> <span style="color:#f00">__declspec</span>(noinline) PCHAR <span style="color:#f00">__cdecl</span> asm_func(
</span></span><span style="display:flex;"><span>  _In_ PCHAR pchBuffer,
</span></span><span style="display:flex;"><span>  _In_ CHAR  chValue
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00">return</span> (PCHAR)memset(pchBuffer, chValue, strlen(pchBuffer));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>]]></content>
        </item>
        
    </channel>
</rss>
