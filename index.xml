<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lamprey Labs</title>
    <link>https://lampreylabs.com/</link>
    <description>Recent content on Lamprey Labs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under the GNU General Public License v3.0</copyright>
    <lastBuildDate>Wed, 11 Jan 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://lampreylabs.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Hacksys Extreme Vulnerable Driver(HEVD) Windows Driver Exploitation - Stack Buffer Overflow</title>
      <link>https://lampreylabs.com/posts/2023/01/hacksys-extreme-vulnerable-driverhevd-windows-driver-exploitation-stack-buffer-overflow/</link>
      <pubDate>Wed, 11 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://lampreylabs.com/posts/2023/01/hacksys-extreme-vulnerable-driverhevd-windows-driver-exploitation-stack-buffer-overflow/</guid>
      <description>Table of Contents  Brief Vulnerability Exploitation and Stabilization  Case I: Intel OS Guard/SMEP not present, KVA Shadow/KPTI disabled   Patch Analysis Honourable Mention  Brief The vulnerability class in question that we are going to hunt for and exploit is a Stack Buffer Overflow in HEVD.sys Windows driver compiled without stack cookie/canary(/GS Buffer Security Check) or StackGuard mitigation. We are also going to look at productization and stabilization of the exploit later on.</description>
    </item>
    
    <item>
      <title>Practical Reverse Engineering - Exercise 2, Page 35</title>
      <link>https://lampreylabs.com/posts/2022/08/practical-reverse-engineering-exercise-2-page-35/</link>
      <pubDate>Sun, 28 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://lampreylabs.com/posts/2022/08/practical-reverse-engineering-exercise-2-page-35/</guid>
      <description>Table of Contents  Question Answer  Question In the example walk-through, we did a nearly one-to-one translation of the assembly code to C. As an exercise, re-decompile this whole function so that it looks more natural. What can you say about the developer’s skill level/experience? Explain your reasons. Can you do a better job?
Answer We already saw a raw decompilation of the sample&amp;rsquo;s DllMain routine in the last exercise using the Hex-Rays decompiler but let&amp;rsquo;s further clean it up and polish it.</description>
    </item>
    
    <item>
      <title>Practical Reverse Engineering - Exercise 1, Page 35</title>
      <link>https://lampreylabs.com/posts/2022/08/practical-reverse-engineering-exercise-1-page-35/</link>
      <pubDate>Wed, 24 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://lampreylabs.com/posts/2022/08/practical-reverse-engineering-exercise-1-page-35/</guid>
      <description>Table of Contents  Question Answer  Question Repeat the walk-through by yourself. Draw the stack layout, including parameters and local variables.
Answer Here is the VirusTotal link to the malware sample in question: wship4.dll
And here is the raw disassembly of the DllMain routine as generated by IDA Pro for reference:
.text:10001C60 ; =============== S U B R O U T I N E ======================================= .text:10001C60 .text:10001C60 ; Attributes: bp-based frame .</description>
    </item>
    
    <item>
      <title>Practical Reverse Engineering - Exercise 4, Page 17</title>
      <link>https://lampreylabs.com/posts/2022/07/practical-reverse-engineering-exercise-4-page-17/</link>
      <pubDate>Thu, 21 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://lampreylabs.com/posts/2022/07/practical-reverse-engineering-exercise-4-page-17/</guid>
      <description>Table of Contents  Question Answer  Question In all of the calling conventions explained, the return value is stored in a 32-bit register(EAX). What happens when the return value does not fit in a 32-bit register? Write a program to experiment and evaluate your answer. Does the mechanism change from compiler to compiler?
Answer Let us consider the following C code:
extern &amp;#34;C&amp;#34; __declspec(noinline) unsigned __int64 __stdcall fun(  void ) {  return 0x4141414142424242; } Compiling it with x86 msvc v19.</description>
    </item>
    
    <item>
      <title>Practical Reverse Engineering - Exercise 3, Page 17</title>
      <link>https://lampreylabs.com/posts/2022/07/practical-reverse-engineering-exercise-3-page-17/</link>
      <pubDate>Wed, 20 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://lampreylabs.com/posts/2022/07/practical-reverse-engineering-exercise-3-page-17/</guid>
      <description>Table of Contents  Question Answer  Question In the example function, addme, what would happen if the stack pointer were not properly restored before executing RET?
Answer Here is the addme function for reference:
push ebp mov ebp, esp movsx eax, word ptr [ebp + 8h] movsx ecx, word ptr [ebp + 0Ch] add eax, ecx mov esp, ebp pop ebp ret In this particular case, ESP remains unmodified(equal to EBP) so mov esp, ebp can be safely omitted from the function epilogue.</description>
    </item>
    
    <item>
      <title>Practical Reverse Engineering - Exercise 2, Page 17</title>
      <link>https://lampreylabs.com/posts/2022/07/practical-reverse-engineering-exercise-2-page-17/</link>
      <pubDate>Tue, 19 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://lampreylabs.com/posts/2022/07/practical-reverse-engineering-exercise-2-page-17/</guid>
      <description>Table of Contents  Question Answer  Question Come up with at least two code sequences to set EIP to 0xAABBCCDD.
Answer There are several instructions in the x86 ISA to manipulate EIP register(control flow instructions) but in this exercise, we are going to see two of the most popular ones(and something which we&amp;rsquo;ve already encountered before in the previous exercise).
 CALL  call 0xAABBCCDD The call instruction is used to call a procedure; it pushes the retdaddr on the stack before changing EIP to the call target effectively transferring control to it.</description>
    </item>
    
    <item>
      <title>Practical Reverse Engineering - Exercise 1, Page 17</title>
      <link>https://lampreylabs.com/posts/2022/07/practical-reverse-engineering-exercise-1-page-17/</link>
      <pubDate>Sat, 16 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://lampreylabs.com/posts/2022/07/practical-reverse-engineering-exercise-1-page-17/</guid>
      <description>Table of Contents  Question Answer  Question Given what you learned about CALL and RET, explain how you would read the value of EIP? Why can’t you just do MOV EAX, EIP?
Answer mov eax, eip is seen as an invalid instruction(not encodable) by any assembler since EIP is not a General Purpose Register(GPR); it is a special purpose register that is used as a pointer to the next instruction to execute(hence known as, extended instruction pointer).</description>
    </item>
    
    <item>
      <title>Practical Reverse Engineering - Exercise 1, Page 11</title>
      <link>https://lampreylabs.com/posts/2022/07/practical-reverse-engineering-exercise-1-page-11/</link>
      <pubDate>Wed, 13 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://lampreylabs.com/posts/2022/07/practical-reverse-engineering-exercise-1-page-11/</guid>
      <description>Table of Contents  Question Answer  Question This function uses a combination SCAS and STOS to do its work. First, explain what is the type of the [EBP+8] and [EBP+C] in line 1 and 8, respectively. Next, explain what this snippet does.
01: mov edi, [ebp + 8] 02: mov edx, edi 03: xor eax, eax 04: or ecx, 0FFFFFFFFh 05: repne scasb 06: add ecx, 2 07: neg ecx 08: mov al, [ebp + 0Ch] 09: mov edi, edx 10: rep stosb 11: mov eax, edx Answer [EBP + 8h] appears to be a char buffer pointer/PCHAR(size = 4 bytes) since it is loaded into EDI register which is then implicitly used by scasb instruction with repne prefix as the memory operand address to compare for a particular byte value specified by AL register.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://lampreylabs.com/about/</link>
      <pubDate>Wed, 13 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://lampreylabs.com/about/</guid>
      <description>Hey there! My name&amp;rsquo;s Upayan. I predominantly go by my &amp;ldquo;winterknife&amp;rdquo; alias nowadays.
I am a software engineer; my interests revolve around the following topics:
 Arcane knowledge of Windows system internals x86 ISA User-mode and kernel-mode CNO Software Development Vulnerability Research and Exploitation  I use the skills gained from my relentless pursuit of the above to solve the toughest problems in support of the information security industry.
This blog is where I&amp;rsquo;ll be sharing random thoughts, experiments, and projects pertaining to low-level computer systems research and software development.</description>
    </item>
    
  </channel>
</rss>
